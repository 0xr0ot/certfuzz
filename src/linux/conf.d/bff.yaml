################################################################
#
# This file specifies the options that BFF will use to fuzz
#   Comments are specified by the "#" character
#
################################################################
# FUZZ CAMPAIGN SETTINGS
################################################################
campaign:
    id: convert v5.2.0

################################################################
# TARGET APPLICATION INVOCATION OPTIONS:
################################################################
#
# Command-line arguments will be split using python shlex.split() so
# be sure to add quotes where needed
# $SEEDFILE will be replaced at runtime with the appropriate
# seed file name.
# Use quotes if the target application has spaces in the path
# examples:
# Name of process to monitor for hangs. This is done by greping the 
# process list, so choose carefully! Usually the same name as "program" 
# will suffice, but in cases where the program is started from a script 
# you may want to list the actual process name.
# This process name is also used to kill the target process when BFF 
# launches the target application from an analyzer, such as gdb or valgrind
# Use quotes if the target application has spaces in its name
target:
    program: ~/convert
    cmdline_template: $PROGRAM $SEEDFILE /dev/null
    killprocname: convert

################################################################
# LOCATIONS FOR FUZZ RUN FILES:
# Output files are placed in [outputdir]/[seedfile]
################################################################
# Location of the fuzzing scripts
# (VMware shared directory if using UbuFuzz VM)

# The location of the seed files

# location of debugger templates

# location of results:
# If results are stored in a shared location, 
# this directory needs to be unique for each fuzzing machine

# dirs local to the fuzzing machine
# Local directory for fuzzing run mutated files.

# Location of file used checked by Linux watchdog to determine
# if fuzzer is still running

directories:
    seedfile_dir: ~/bff/seedfiles/examples
    working_dir: ~/fuzzing
    results_dir: ~/results
    debugger_template_dir: ~/bff/certfuzz/debuggers/templates
    watchdog_file: /tmp/bff_watchdog


################################################################
# VERIFIER PARAMETERS
################################################################
#
# Include backtrace frames that aren't part of a loaded library?
# Set this value to False if you wish to consider unmapped stack
# frames in the crash hashes. This can be useful for target application
# that perform JIT compilation

# Save cases that cause failed ASSERTs?  If set to 1, then __assert_fail termination, 
# e.g. via assert(), it will be considered a crash.

# Use valgrind (and callgrind)
# Note that valgrind can be slow. Disabling this option can improve throughput

# Use PIN to get call traces for every crash, as opposed to just those
# that result in total stack corruption.
# PIN is even slower than valgrind

# Obtain minimally-different testcase for each unique crash

# Minimize to a metasploit string
# Note: this is in addition to minimize to seedfile if minimize_crashers=True
# Also, if minimize_to_string is true, then its minimized result will be used
# for all subsequent analyses (i.e., valgrind, callgrind, etc.)
# Disabled by default due to amount of time that the minimization takes.
# Stand-alone string minimization can be done using tools/minimize.py.

# Save crashes even when they are unique?  If set to True, all
# crashing inputs are saved, even when their backtraces are not
# unique.

# Recycle crashing testcases as seed files for further fuzzing.
# This can improve the number of unique crash hashes found, however this may
# just demonstrate weaknesses in backtrace-based uniqueness determination
# rather than finding new underlying vulnerabilities.

verifier:
    exclude_unmapped_frames: True
    savefailedasserts: False
    use_valgrind: True
    use_pin_calltrace: False
    minimize_to_string: False
    keep_duplicates: False
# maximum time (seconds) to let the program run to capture valgrind output:
    valgrind_timeout: 120

runoptions:
    first_iteration: 0
    seed_interval: 20
    minimize: True
# Minimization can sometimes take a long time, and time spent minimizing
# is time not spent fuzzing. If a minimization run exceeds this time
# (in seconds) the minimization will terminate (keeping whatever progress
# it has made at that point) and return to fuzzing.
    minimizer_timeout: 3600
#    keep_unique_faddr: False
#    keep_all_duplicates: False
    recycle_crashers: False

# maximum time (seconds) that process specified by "killprocname" option 
# can run before it's killed via killproc.sh, 
# which is used to kill stray processes.  Normally, zzuf will kill
# the target process if the above timeout is reached.
    killproctimeout: 130
# Set value for the Linux watchdog timer. If watchdog_file is not touched 
# for a period longer than this value (seconds), then the vm is rebooted 
# by the watchdog.
# Set to 0 to disable watchdog functionality.
    watchdogtimeout: 3600
    
    
fuzzer:
    fuzzer: bytemut
    fuzz_zip_container: False
runner:
    runner: zzufrun
# maximum program execution time (seconds) that BFF will allow:
    runtimeout: 5
debugger:
    debugger: gdb
# maximum time (seconds) to let the program run to capture debugger and
# CERT Triage Tools exploitable output.
    runtimeout: 60
# number of backtrace levels to hash for uniqueness.
# Increase this number for more crash uniqueness granularity.
# Decrease this number if you think that you are getting too many
# duplicate crashes.
    backtracelevels: 5
    
