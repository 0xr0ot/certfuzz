################################################################
#
# This file specifies the options that BFF will use to fuzz
#   Comments are specified by the "#" character
#
################################################################
# FUZZ CAMPAIGN SETTINGS
################################################################
campaign:
    id: convert v5.2.0

################################################################
# TARGET APPLICATION INVOCATION OPTIONS:
################################################################
#
# Command-line arguments will be split using python shlex.split() so
# be sure to add quotes where needed
# $SEEDFILE will be replaced at runtime with the appropriate
# seed file name.
# Use quotes if the target application has spaces in the path
# examples:
# Name of process to monitor for hangs. This is done by greping the 
# process list, so choose carefully! Usually the same name as "program" 
# will suffice, but in cases where the program is started from a script 
# you may want to list the actual process name.
# This process name is also used to kill the target process when BFF 
# launches the target application from an analyzer, such as gdb or valgrind
# Use quotes if the target application has spaces in its name
target:
    program: ~/convert
    cmdline_template: $PROGRAM $SEEDFILE /dev/null
    killprocname: convert

################################################################
# LOCATIONS FOR FUZZ RUN FILES:
# Output files are placed in [outputdir]/[seedfile]
################################################################
# Location of the fuzzing scripts
# (VMware shared directory if using UbuFuzz VM)

# The location of the seed files

# location of debugger templates

# location of results:
# If results are stored in a shared location, 
# this directory needs to be unique for each fuzzing machine

# dirs local to the fuzzing machine
# Local directory for fuzzing run mutated files.

# Location of file used checked by Linux watchdog to determine
# if fuzzer is still running

directories:
    seedfile_origin_dir: ~/bff/seedfiles/examples
    debugger_template_dir: ~/bff/certfuzz/debuggers/templates
    output_dir: ~/results
    local_dir: ~/fuzzing
    watchdog_file: /tmp/bff_watchdog

################################################################
# ZZUF FUZZER PARAMETERS
################################################################
# Use zzuf's "copy" mode, which creates a temporary fuzzed file
# Default is 1, where zzuf will determine the file to fuzz, mangle it as
# a randomly-named file in $TMPDIR and then open that with the target app.
# This mode is compatible with more applications, but it can be slower in
# some cases, due to the extra file i/o required.
# If set to 0, zzuf will use LD_PRELOAD to mangle input in memory, rather
# than creating a temporary file. Note that this mode can interfere with
# some target applications.
# OSX Cocoa applications require copymode=1

# The zzuf seed number to start with

# How many iterations you want zzuf to try per seedfile/range selection
# If you have a large number of seed files and/or the target application
# is slow, you may wish to make this value smaller to get better coverage
# in a reasonable amount of time.

zzuf:
    copymode: 1
    start_seed: 0
    seed_interval: 20

################################################################
# VERIFIER PARAMETERS
################################################################
#
# number of backtrace levels to hash for uniqueness.
# Increase this number for more crash uniqueness granularity.
# Decrease this number if you think that you are getting too many
# duplicate crashes.

# Include backtrace frames that aren't part of a loaded library?
# Set this value to False if you wish to consider unmapped stack
# frames in the crash hashes. This can be useful for target application
# that perform JIT compilation

# Save cases that cause failed ASSERTs?  If set to 1, then __assert_fail termination, 
# e.g. via assert(), it will be considered a crash.

# Use valgrind (and callgrind)
# Note that valgrind can be slow. Disabling this option can improve throughput

# Use PIN to get call traces for every crash, as opposed to just those
# that result in total stack corruption.
# PIN is even slower than valgrind

# Obtain minimally-different testcase for each unique crash

# Minimize to a metasploit string
# Note: this is in addition to minimize to seedfile if minimize_crashers=True
# Also, if minimize_to_string is true, then its minimized result will be used
# for all subsequent analyses (i.e., valgrind, callgrind, etc.)
# Disabled by default due to amount of time that the minimization takes.
# Stand-alone string minimization can be done using tools/minimize.py.

# Save crashes even when they are unique?  If set to True, all
# crashing inputs are saved, even when their backtraces are not
# unique.

# Recycle crashing testcases as seed files for further fuzzing.
# This can improve the number of unique crash hashes found, however this may
# just demonstrate weaknesses in backtrace-based uniqueness determination
# rather than finding new underlying vulnerabilities.

verifier:
    backtracelevels: 5
    exclude_unmapped_frames: True
    savefailedasserts: False
    use_valgrind: True
    use_pin_calltrace: False
    minimizecrashers: True
    minimize_to_string: False
    recycle_crashers: False
    keep_duplicates: False


################################################################
# APPLICATION TIMEOUTS
################################################################
#
# maximum program execution time (seconds) that BFF will allow:

# maximum time (seconds) that process specified by "killprocname" option 
# can run before it's killed via killproc.sh, 
# which is used to kill stray processes.  Normally, zzuf will kill
# the target process if the above timeout is reached.

# maximum time (seconds) to let the program run to capture debugger and
# CERT Triage Tools exploitable output.

# maximum time (seconds) to let the program run to capture valgrind output:

# Set value for the Linux watchdog timer. If watchdog_file is not touched 
# for a period longer than this value (seconds), then the vm is rebooted 
# by the watchdog.
# Set to 0 to disable watchdog functionality.

# Minimization can sometimes take a long time, and time spent minimizing
# is time not spent fuzzing. If a minimization run exceeds this time
# (in seconds) the minimization will terminate (keeping whatever progress
# it has made at that point) and return to fuzzing.

timeouts:
    progtimeout: 5
    killproctimeout: 130
    debugger_timeout: 60
    valgrindtimeout: 120
    watchdogtimeout: 3600
    minimizertimeout: 3600

# adding these sections for compatibility with FOE config style

runoptions:
#    first_iteration: 0
#    seed_interval: 1
    minimize: True
#    minimizer_timeout: 3600
#    keep_unique_faddr: False
#    keep_all_duplicates: False
#    recycle_crashers: False
fuzzer:
    fuzzer: bytemut
    fuzz_zip_container: False
runner:
    runner: zzufrun
    runtimeout: 5
debugger:
    debugger: gdb
    runtimeout: 60
